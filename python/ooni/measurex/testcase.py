"""
Contains code to manage measurex testcases.

A testcase is a YAML file containing a serialized version of the measurex
cache generated by a previous run of ooniprobe, along with metadata that
identify and explain the testcase.

We can force ooniprobe to run using the cache and without networking
support. This trick allows us to rerun measurements collected in
censored environments locally and evaluate our algorithms.

To import test cases from a tarball generated by ./python/testcase/create
you use the import_from_tarball function. This function converts the
test case to a YAML file stored into the specified destination directory.

You can then load and consume YAML test cases using load.
"""

from __future__ import annotations

import datetime
import json
import logging
import os
import re
import tarfile
from typing import (
    Any,
    BinaryIO,
    Dict,
    Iterator,
    List,
    Optional,
    Protocol,
    Set,
    Tuple,
)
import yaml

from ..dataformat.flat import (
    MeasurexDNSLookupMeasurement,
    MeasurexEndpointMeasurement,
)

from ..dataformat.typecast import (
    DictWrapper,
    StrWrapper,
)

from ..tabulatex import (
    Tabular,
)

from .decode import (
    decode_and_print_dns,
    decode_and_print_endpoint,
)

#
# Common
#
# This section contains common definitions and code.
#

_VERSION = 1

_SUPPORTED_VERSIONS = set(
    [
        _VERSION,
    ]
)

_CACHE_ENTRY_PATTERN = re.compile(
    r"^testcase/cache/(probe|th)/(dns|dnsping|endpoint)/[0-9a-f]{2}/[0-9a-f]{64}-d$"
)

_MANIFEST_PATTERN = re.compile(r"^testcase/manifest.json$")

_TIMESTAMP_PATTERN = re.compile(r"^[0-9]{8}T[0-9]{6}Z$")


def _is_entry(value: str) -> bool:
    """Returns whether the given filepath is a cache entry's filepath."""
    return not not _CACHE_ENTRY_PATTERN.match(value)


def _is_manifest(value: str) -> bool:
    """Returns whether the given filepath is the manifest's filepath"""
    return not not _MANIFEST_PATTERN.match(value)


def _is_timestamp(value: str) -> bool:
    """Returns whether the given string is a timestamp with the expected format."""
    return not not _TIMESTAMP_PATTERN.match(value)


def _utcnowstring():
    """Returns the current UTC time as a string."""
    return datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")


#
# Importing test cases
#
# This section contains code to import test cases from compressed
# tarball files to editable YAML files.
#


def _extract_tar_member(tar, member):
    """Extracts a tar member and parses it from JSON."""
    infp = tar.extractfile(member)
    if infp is None:
        raise RuntimeError("cannot read tarfile entry")
    return json.load(infp)


def _creation_time(manifest, filename):
    """Helper function to obtain the creation time from either the manifest
    or the filename as a fallback. We don't validate the creation time as
    a timestamp here; the caller should do that. This function is here because
    some of the initial test cases that were created did not contain the
    creation date inside the manifest. So we need to try also using the filename."""
    try:
        return manifest["created"]
    except KeyError:
        return os.path.basename(filename.split("-")[0])


def import_from_tarball(destdir: str, filename: str) -> str:
    """Takes in input a compressed tarball containing a JSON test case and
    generates a YAML containing the test case inside destdir.

    Returns to the caller the full path of the generated YAML file."""
    manifest, cachedict = {}, {}
    with tarfile.open(filename, "r:gz") as tar:
        for member in tar.getmembers():
            if _is_entry(member.name):
                value = _extract_tar_member(tar, member)
                cachedict[member.name] = value
                continue
            if _is_manifest(member.name):
                value = _extract_tar_member(tar, member)
                manifest.update(value)
                continue
    if not manifest:
        raise RuntimeError("manifest.json missing inside tarball")
    if not cachedict:
        raise RuntimeError("cache empty inside tarball")
    now = _utcnowstring()
    manifest["imported"] = now
    created = _creation_time(manifest, filename)
    if not _is_timestamp(created):
        raise RuntimeError("finvalid timestamp pattern: {created}")
    manifest["created"] = created  # ensure it's present in the header
    outfile = os.path.join(destdir, f"{created}-testcase.yaml")
    data_format_version = _VERSION
    with open(outfile, "wb") as filep:
        data = yaml.dump_all(
            [data_format_version, manifest, cachedict],
            explicit_start=True,
            explicit_end=True,
        )
        filep.write(data.encode("utf-8"))
    return outfile


#
# Load
#
# Implements loading from YAML files.
#



class Manifest:
    """Manifest of a test case."""

    def __init__(self, filepath: str, data: DictWrapper):
        self.filepath = filepath
        self.command = [StrWrapper(x) for x in data.getlist("command")]
        self.created = data.getstring("created")
        self.description = data.getstring("description")
        self.imported = data.getstring("imported")
        self.probe_asn = data.getstring("probe_asn")
        self.probe_cc = data.getstring("probe_cc")
        self.url = data.getstring("url")

    def as_tabular(self) -> Tabular:
        """Converts the test case to tabular format."""
        return Tabular.create(
            [
                ("filepath", self.filepath),
                ("url", self.url),
                ("probe_asn", self.probe_asn),
                ("probe_cc", self.probe_cc),
                ("description", self.description),
            ]
        )


class EntryMeasurement(Protocol):
    """Entry is an entry inside the cache."""

    def id(self) -> int:
        """Returns the ID of this cache entry or zero."""
        return 0

    def kind(self) -> str:
        """Returns the kind of this entry"""
        return ""

    def as_tabular(self) -> Tabular:
        """Returns a tabular representation of this entry that
        depends on the kind of the entry."""
        return Tabular()

    def decode_and_print(self) -> None:
        """Decodes round trips inside this entry and prints them."""

    def as_dns_lookup_measurement(self) -> Optional[MeasurexDNSLookupMeasurement]:
        """Returns the underlying DNSLookupMeasurement if possible."""
        return None

    def as_endpoint_measurement(self) -> Optional[MeasurexEndpointMeasurement]:
        """Returns the underlying EndpointMeasurement if possible."""
        return None


class _DNSLookupMeasurement:
    """Wraps a MeasurexDNSLookupMeasurement."""

    def __init__(self, probe_th: str, data: DictWrapper):
        self._probe_th = probe_th
        self._dns = MeasurexDNSLookupMeasurement(data)

    def id(self) -> int:
        return self._dns.id

    def kind(self) -> str:
        return "dns"

    def as_tabular(self) -> Tabular:
        return Tabular.create(
            [
                ("id", self._dns.id),
                ("origin", self._probe_th),
                ("resolver", self._dns.lookup.resolver_url()),
                ("lookup_type", self._dns.lookup.lookup_type),
                ("domain", self._dns.lookup.domain),
                ("failure", self._dns.lookup.failure),
                ("addresses", self._dns.lookup.addresses),
                ("ptrs", self._handle_many_ptrs(self._dns.lookup.ptr)),
            ]
        )

    def decode_and_print(self) -> None:
        decode_and_print_dns(self._probe_th, self._dns)

    def as_dns_lookup_measurement(self) -> Optional[MeasurexDNSLookupMeasurement]:
        return self._dns

    def as_endpoint_measurement(self) -> Optional[MeasurexEndpointMeasurement]:
        return None

    @staticmethod
    def _handle_many_ptrs(src: List[str]) -> List[str]:
        if len(src) > 1:
            src = src[:1]
            src.extend(["..."])
        return src


class _EndpointMeasurement:
    """Wraps a MeasurexEndpointMeasurement."""

    def __init__(self, probe_th: str, data: DictWrapper):
        self._probe_th = probe_th
        self._endpoint = MeasurexEndpointMeasurement(data, include_body=True)

    def id(self) -> int:
        return self._endpoint.id

    def kind(self) -> str:
        return "endpoint"

    def as_tabular(self) -> Tabular:
        return Tabular.create(
            [
                ("id", self._endpoint.id),
                ("origin", self._probe_th),
                ("url", self._endpoint.url),
                ("network", self._endpoint.network),
                ("address", self._endpoint.address),
                ("orig_cookies", self._endpoint.orig_cookies),
                ("failed_operation", self._endpoint.failed_operation),
                ("failure", self._endpoint.failure),
                ("location", self._endpoint.location),
                ("title", self._endpoint.http_title),
                ("status", self._endpoint.status_code()),
                ("body_len", self._endpoint.response_body_length()),
            ]
        )

    def decode_and_print(self) -> None:
        decode_and_print_endpoint(self._probe_th, self._endpoint)

    def as_dns_lookup_measurement(self) -> Optional[MeasurexDNSLookupMeasurement]:
        return None

    def as_endpoint_measurement(self) -> Optional[MeasurexEndpointMeasurement]:
        return self._endpoint


class _Unsupported:
    """Wraps an unsupported measurement"""

    def id(self) -> int:
        return 0

    def kind(self) -> str:
        return ""

    def as_tabular(self) -> Tabular:
        return Tabular()

    def decode_and_print(self) -> None:
        pass

    def as_dns_lookup_measurement(self) -> Optional[MeasurexDNSLookupMeasurement]:
        return None

    def as_endpoint_measurement(self) -> Optional[MeasurexEndpointMeasurement]:
        return None


class Entry:
    """Entry is an entry inside the cache."""

    def __init__(self, filepath: str, data: DictWrapper):
        self._filename = filepath
        self._time = data.getstring("T")
        self._measurement = self._load_entry(filepath, data.getdictionary("M"))
        self._raw = data

    def filename(self) -> str:
        """Returns the filename of this entry."""
        return self._filename

    def as_original_dict(self) -> Dict:
        """Returns the entry as the original dict that generated it."""
        return self._raw.unwrap()

    def as_tabular(self) -> Tabular:
        """Convenience function for converting to tabular."""
        return self._measurement.as_tabular()

    def kind(self) -> str:
        """Convenience function for getting the kind."""
        return self._measurement.kind()

    def measurement(self) -> EntryMeasurement:
        """Returns the underlying measurement."""
        return self._measurement

    def id(self) -> int:
        """Convenience function for getting the ID."""
        return self._measurement.id()

    @staticmethod
    def _load_entry(filename: str, data: DictWrapper) -> EntryMeasurement:
        """Parse a cache entry from a Python dictionary to the specific
        dataformat type representing such an entry. We exploit the filename
        to determine the datatype because the filename itself contains a
        string that encodes the correct type."""
        vecfilename = filename.split("/")
        kind = vecfilename[3]
        probe_th = vecfilename[2]
        if kind == "dns":
            return _DNSLookupMeasurement(probe_th, data)
        if kind == "endpoint":
            return _EndpointMeasurement(probe_th, data)
        logging.warning(f"BUG: no support for {kind} type entries")
        return _Unsupported()


class Cache:
    """Contains the whole cache."""

    def __init__(self, data: DictWrapper):
        self._cache: Dict[str, List[Entry]] = {}
        for key in data.unwrap():
            filename = StrWrapper(key).unwrap()
            if not _CACHE_ENTRY_PATTERN.match(filename):
                logging.warning(f"Cache: invalid filename: {filename}")
                continue
            for entry in data.getlist(key):
                self._cache.setdefault(filename, [])
                self._cache[filename].append(Entry(filename, DictWrapper(entry)))

    def entries(self) -> Iterator[Tuple[str, Entry]]:
        """Yields all the cache entries"""
        for filename, entries in self._cache.items():
            for entry in entries:
                yield filename, entry

    def _measurements(self, filter: str, ids: Set[int]) -> Iterator[EntryMeasurement]:
        """Yields all the DNS measurements."""
        for values in self._cache.values():
            for value in values:
                if value.kind() == filter and (not ids or value.id() in ids):
                    yield value.measurement()

    def dns_measurements(self, ids: Set[int]) -> Iterator[EntryMeasurement]:
        """Yields all the DNS measurements."""
        return self._measurements("dns", ids)

    def endpoint_measurements(self, ids: Set[int]) -> Iterator[EntryMeasurement]:
        """Yields all the endpoint measurements."""
        return self._measurements("endpoint", ids)

    def _measurements_as_tabular(self, filter: str) -> Tabular:
        tab = Tabular()
        for values in self._cache.values():
            for value in values:
                if value.kind() == filter:
                    tab.append(value.as_tabular())
        return tab

    def dns_measurements_as_tabular(self) -> Tabular:
        """Returns all DNS measurements as tabular data."""
        return self._measurements_as_tabular("dns")

    def endpoint_measurements_as_tabular(self) -> Tabular:
        return self._measurements_as_tabular("endpoint")


class TestCase:
    """Represents a test case loaded from a YAML file. This class should be
    used as a context manager to close the underlying YAML file."""

    def __init__(self, filepath: str, filep: BinaryIO, iter: Iterator[Any]):
        self._manifest = Manifest(filepath, DictWrapper(next(iter)))
        self._cache: Optional[Cache] = None
        self._iter: Iterator[Any] = iter
        self._filep = filep

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def close(self):
        self._filep.close()

    def manifest(self) -> Manifest:
        """Returns the test case's manifest."""
        return self._manifest

    def cache(self) -> Cache:
        """Returns the test case's cache."""
        if self._cache is None:
            self._cache = Cache(DictWrapper(next(self._iter)))
        return self._cache


def load(filename: str) -> TestCase:
    """Loads the test case from a YAML file and returns it."""
    filep = open(filename, "rb")
    try:
        source = yaml.safe_load_all(filep)
        format_version = next(source)
        if format_version not in _SUPPORTED_VERSIONS:
            raise TypeError(f"unsupported data format version: {format_version}")
    except:
        filep.close()
        raise
    else:
        return TestCase(filename, filep, source)  # takes ownership of filep
