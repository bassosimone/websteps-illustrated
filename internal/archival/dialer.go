package archival

//
// Saves dial and net.Conn events
//

import (
	"context"
	"net"
	"time"

	"github.com/bassosimone/websteps-illustrated/internal/model"
	"github.com/bassosimone/websteps-illustrated/internal/netxlite"
)

// FlatFailure is the flat data format representation of failure.
type FlatFailure string

// NewFlatFailure constructs a new FlatFailure from an error.
func NewFlatFailure(err error) FlatFailure {
	if err != nil {
		return FlatFailure(err.Error())
	}
	return ""
}

// ToArchivalFailure converts from FlatFailure to ArchivalFailure.
func (ff FlatFailure) ToArchivalFailure() *string {
	if ff != "" {
		s := string(ff)
		return &s
	}
	return nil
}

// IsSuccess returns true if there is no failure, false otherwise.
func (ff FlatFailure) IsSuccess() bool {
	return ff == ""
}

// NetworkEvent contains a network event. This kind of events
// are generated by Dialer, QUICDialer, Conn, QUICConn.
type NetworkEvent struct {
	Count      int
	Failure    FlatFailure
	Finished   time.Time
	Network    string
	Operation  string
	RemoteAddr string
	Started    time.Time
}

// DialContext dials with the given dialer with the given arguments
// and stores the dial result inside of this saver.
func (s *Saver) DialContext(ctx context.Context,
	dialer model.Dialer, network, address string) (net.Conn, error) {
	started := time.Now()
	conn, err := dialer.DialContext(ctx, network, address)
	s.appendNetworkEvent(&NetworkEvent{
		Count:      0,
		Failure:    NewFlatFailure(err),
		Finished:   time.Now(),
		Network:    network,
		Operation:  netxlite.ConnectOperation,
		RemoteAddr: address,
		Started:    started,
	})
	return conn, err
}

// Read reads from the given conn and stores the results in the saver.
func (s *Saver) Read(conn net.Conn, buf []byte) (int, error) {
	network := conn.RemoteAddr().Network()
	remoteAddr := conn.RemoteAddr().String()
	started := time.Now()
	count, err := conn.Read(buf)
	s.appendNetworkEvent(&NetworkEvent{
		Count:      count,
		Failure:    NewFlatFailure(err),
		Finished:   time.Now(),
		Network:    network,
		Operation:  netxlite.ReadOperation,
		RemoteAddr: remoteAddr,
		Started:    started,
	})
	return count, err
}

// Write writes to the given conn and stores the results into the saver.
func (s *Saver) Write(conn net.Conn, buf []byte) (int, error) {
	network := conn.RemoteAddr().Network()
	remoteAddr := conn.RemoteAddr().String()
	started := time.Now()
	count, err := conn.Write(buf)
	s.appendNetworkEvent(&NetworkEvent{
		Count:      count,
		Failure:    NewFlatFailure(err),
		Finished:   time.Now(),
		Network:    network,
		Operation:  netxlite.WriteOperation,
		RemoteAddr: remoteAddr,
		Started:    started,
	})
	return count, err
}

func (s *Saver) appendNetworkEvent(ev *NetworkEvent) {
	s.mu.Lock()
	s.trace.Network = append(s.trace.Network, ev)
	s.mu.Unlock()
}
