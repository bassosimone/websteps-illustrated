#!/usr/bin/env python3

"""Allows to navigate measurements."""

import argparse
from dnslib import DNSRecord
import json
import sys
import tabulate
from typing import Any
from typing import Dict
from typing import List

sys.path.insert(0, ".")

from websteps.websteps import load as websteps_load
from websteps.websteps import AnalysisDNSOrEndpoint
from websteps.websteps import DNSSinglePingReply
from websteps.websteps import DNSSinglePingResult
from websteps.dblike import Entry
from websteps.dblike import Kind
from websteps.dblike import MeasurementDB


def jsonl_reader(filepath: str):
    """Reads a JSONL file returning each measurement."""
    with open(filepath, "rb") as filep:
        for line in filep:
            try:
                measurement = json.loads(line)
            except ValueError:
                continue
            else:
                yield measurement


def load(filepath) -> List[MeasurementDB]:
    """Loads measurements from file."""
    out: List[MeasurementDB] = []
    for measurement in jsonl_reader(filepath):
        tk = measurement.get("test_keys")
        if not tk:
            print("warning: missing test_keys")
            continue
        try:
            meas = websteps_load(tk)
        except ValueError as exc:
            print(f"warning: cannot load measurement: {exc}")
            continue
        mdb = MeasurementDB(meas)
        out.append(mdb)
    return out


def print_table(table: List[Dict[str, Any]]):
    """Pretty-prints a table."""
    print(tabulate.tabulate(table, headers="keys", tablefmt="grid"))


def s_command_help():
    """Prints the help screen."""
    print("")
    print("  d<id>")
    print("    decodes the observation with the given <id>")
    print("")
    print("  h")
    print("    prints this help screen")
    print("")
    print("  j")
    print("    views the whole measurement JSON")
    print("")
    print("  j<id>")
    print("    views the JSON of the observation or analysis with the given <id>")
    print("")
    print("  la<id>")
    print("    lists probe's analysis for the given URL <id>")
    print("")
    print("  lia")
    print('    lists "interesting" analysis')
    print("")
    print("  lm")
    print("    lists the currently-selected measurement")
    print("")
    print("  lu")
    print("    lists urls observations")
    print("")
    print("  q")
    print("    returns to the main environment")
    print("")
    print("  v<id>")
    print("    views the observation or analysis with the given ID")
    print("")


def s_command_d(meas: MeasurementDB, command: str):
    """Implements the d command of the s environment."""
    try:
        idx = int(command[1:])
    except ValueError:
        print("s: argument for `d` must be a number")
        return
    try:
        entry = meas.find_entry(idx)
    except IndexError:
        print(f"s: entry {idx} not found")
        return
    if entry.kind() == Kind.DNS_SINGLE_PING_RESULT:
        result: DNSSinglePingResult = entry.unwrap()
        print(DNSRecord.parse(result.query))
        return
    if entry.kind() == Kind.DNS_SINGLE_PING_REPLY:
        reply: DNSSinglePingReply = entry.unwrap()
        print(DNSRecord.parse(reply.reply))
        return
    print(f"s: cannot decode: {entry}")


def s_command_j(meas: MeasurementDB, command: str):
    """Implements the j command of the s environment."""
    if len(command[1:]) <= 0:
        json.dump(meas.raw(), sys.stdout, indent=4)
        sys.stdout.write("\n")
        return
    try:
        idx = int(command[1:])
    except ValueError:
        print("s: argument for `j` must be a number")
        return
    try:
        entry = meas.find_entry(idx)
    except IndexError:
        print(f"s: entry {idx} not found")
        return
    json.dump(entry.raw(), sys.stdout, indent=4)
    sys.stdout.write("\n")


def s_command_v(meas: MeasurementDB, command: str):
    """Implements the v command of the s environment."""
    try:
        idx = int(command[1:])
    except ValueError:
        print("s: argument for `v` must be a number")
        return
    try:
        entry = meas.find_entry(idx)
    except KeyError:
        print(f"s: entry {idx} not found")
        return
    print("")
    print(f"kind: {entry.kind()}")
    print(f"origin: {entry.origin()}")
    print("")
    print_table([entry.dict()])
    print("")
    print("hint: use `j<id>' to view the corresponding JSON")
    print("")


def s_command_lm(idx: int, meas: MeasurementDB):
    """Implements the lm command of the s environment."""
    print("")
    print(f"viewing selected measurement {idx}")
    print("")
    print_table([{"url": meas.url(), "flags": meas.tags()}])
    print("")
    print("hint: use `lu` to list the URLs measured within this measurement")
    print("hint: use `h' for help")
    print("")


def s_command_lia(meas_idx: int, meas: MeasurementDB):
    """Implements the lia command of the s environment."""
    entries: List[Entry] = []
    for elem in meas.list_analysis():
        analysis: AnalysisDNSOrEndpoint = elem.unwrap()
        if not analysis.flags.tags():
            continue
        entries.append(elem)
    if len(entries) <= 0:
        print("")
        print('no "interesting" analysis to show')
        print("")
        print("hint: use `la<id>' to list all analysis for the URL with <id>")
        print("hint: use `h' for help")
        print("")
        return
    print("")
    print(f'viewing "interesting" analysis for selected measurement {meas_idx}')
    print("")
    print_table([entry.dict() for entry in entries])
    print("")
    print("hint: use `v<id>' to view the observation or analyis with the given <id>")
    print("hint: use `h' for help")
    print("")


def s_command_la(meas_idx: int, meas: MeasurementDB, command: str):
    """Implements the la command of the s environment."""
    try:
        url_idx = int(command[2:])
    except ValueError:
        print("s: argument for `la' must be a number")
        return
    entries = [elem.dict() for elem in meas.list_analysis(url_idx)]
    if not entries:
        print(f"warning: cannot find analysis for URL {url_idx}")
        return
    print("")
    print(f"viewing analysis for selected measurement {meas_idx} and URL {url_idx}")
    print("")
    print_table(entries)
    print("")
    print("hint: use `v<id>' to view the observation or analyis with the given <id>")
    print("hint: use `h' for help")
    print("")


def s_command_lu(idx: int, meas: MeasurementDB):
    """Implements the lu command of the s environment."""
    print("")
    print(f"viewing the URLs measured as part of selected measurement {idx}")
    print("")
    entries = meas.list_urls()
    print_table([elem.dict() for elem in entries])
    print("")
    print(f'hint: use `lia\' to list "interesting" analysis')
    print("hint: use `h' for help")
    print("")


def s_truncate_url(meas: MeasurementDB):
    """Returns meas' URL and possibly truncates it."""
    url = meas.url()
    if len(url) > 47:
        url = url[:47] + " ..."
    return url


def s_interactive(idx: int, meas: MeasurementDB):
    """The s environment (aka "selected" measurement)."""
    print("")
    print(f"selecting measurement {idx}; entering into the `s' environment...")
    print("")
    print("hint: use `lm' to print the selected measurement")
    print("hint: use `h' for help")
    print("")
    while True:
        command = input(f"🐚🐚🐚 s:{idx} [{s_truncate_url(meas)}]> ")
        if command == "q":
            print("")
            print("leaving the `s' environment...")
            print('hint: use `li\' to list "interesting" measurements')
            print("")
            break
        if command.startswith("d"):
            s_command_d(meas, command)
            continue
        if command == "h":
            s_command_help()
            continue
        if command.startswith("j"):
            s_command_j(meas, command)
            continue
        if command.startswith("la"):
            s_command_la(idx, meas, command)
            continue
        if command == "lia":
            s_command_lia(idx, meas)
            continue
        if command == "lm":
            s_command_lm(idx, meas)
            continue
        if command == "lu":
            s_command_lu(idx, meas)
            continue
        if command.startswith("v"):
            s_command_v(meas, command)
            continue
        print(f"s: {command}: command not found (try 'h' for help)")


def main_command_help():
    """Prints the help screen."""
    print("")
    print("  h")
    print("    prints this help screen")
    print("")
    print("  j<id>")
    print("    prints the JSON of the measurement with <id>")
    print("")
    print("  l")
    print("    lists measurements")
    print("")
    print("  li")
    print("    lists interesting measurements")
    print("")
    print("  q")
    print("    exits")
    print("")
    print("  s<id>")
    print("    selects the measurement with the given ID")
    print("")


def main_command_j(meas: List[MeasurementDB], command: str):
    """Implements the j command of the s environment."""
    try:
        idx = int(command[1:])
    except ValueError:
        print("main: argument for `j` must be a number")
        return
    try:
        entry = meas[idx]
    except IndexError:
        print(f"s: entry {idx} not found")
        return
    json.dump(entry.raw(), sys.stdout, indent=4)
    sys.stdout.write("\n")


def main_command_l(msmts: List[MeasurementDB], all: bool):
    """Lists all the available measurements."""
    summary: List[Dict[str, Any]] = []
    for idx, meas in enumerate(msmts):
        entry = {"idx": idx, "url": meas.url(), "flags": meas.tags()}
        if not all and len(entry["flags"]) <= 0:
            continue
        summary.append(entry)
    if len(summary) <= 0:
        print("")
        print('no "interesting" measurements to show')
        print("")
        print("hint: use `l' to list all measurements")
        print("hint: use `h' for help")
        print("")
        return
    print("")
    print_table(summary)
    print("")
    print("hint: use `s<id>' to select the measurement with the given <id>")
    print("hint: use `h' for help")
    print("")


def main_command_s(msmts: List[MeasurementDB], command: str):
    """Implements the s command of the CLI."""
    try:
        idx = int(command[1:])
    except ValueError:
        print("dbsteps: argument for `s' must be a number")
        return
    try:
        meas = msmts[idx]
    except IndexError:
        print(f"dbsteps: measurement {idx} not found")
        return
    s_interactive(idx, meas)


def main_interactive(msmts: List[MeasurementDB]):
    """Runs an interactive shell allowing to see measurements."""
    print("")
    print(f"loaded {len(msmts)} measurements; entering the main environment...")
    print("")
    print('hint: use `li\' to list "interesting" measurements')
    print("hint: use `h' for help")
    print("")
    while True:
        command = input("🐚🐚🐚 main> ")
        if command == "q":
            break
        if command.startswith("j"):
            main_command_j(msmts, command)
            continue
        if command == "h":
            main_command_help()
            continue
        if command == "l" or command == "li":
            main_command_l(msmts, command != "li")
            continue
        if command.startswith("s"):
            main_command_s(msmts, command)
            continue
        print(f"dbsteps: {command}: command not found (try 'h' for help)")


def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Process some integers.")
    parser.add_argument(
        "-f",
        dest="file",
        action="store",
        help="specify JSONL file containing measurements",
        required=True,
    )
    args = parser.parse_args()
    msmts = load(args.file)
    try:
        main_interactive(msmts)
    except EOFError:
        pass


if __name__ == "__main__":
    main()
